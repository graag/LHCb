/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooIpatiaCommon.h" 
#include "RooIpatia.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 

RooIpatia::RooIpatia(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _l,
                        RooAbsReal& _zeta,
                        RooAbsReal& _fb,
                        RooAbsReal& _sigma,
                        RooAbsReal& _mu,
                        RooAbsReal& _a,
                        RooAbsReal& _n) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   l("l","l",this,_l),
   zeta("zeta","zeta",this,_zeta),
   fb("fb","fb",this,_fb),
   sigma("sigma","sigma",this,_sigma),
   mu("mu","mu",this,_mu),
   a("a","a",this,_a),
   n("n","n",this,_n)
 { 
 } 


 RooIpatia::RooIpatia(const RooIpatia& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   l("l",this,other.l),
   zeta("zeta",this,other.zeta),
   fb("fb",this,other.fb),
   sigma("sigma",this,other.sigma),
   mu("mu",this,other.mu),
   a("a",this,other.a),
   n("n",this,other.n)
 { 
 } 



 Double_t RooIpatia::evaluate() const 
 { 
   Double_t d = x-mu;
   Double_t cons0 = sqrt(zeta);
   Double_t alpha, beta, delta,  cons1, phi, A, B, k1, k2;
   Double_t asigma = a*sigma;
   Double_t out = 0.0;
   if (zeta!= 0.) {
     phi = BK(l+1,zeta)/BK(l,zeta); // careful if zeta -> 0. You can implement a function for the ratio, but carefull again that |nu + 1 | != |nu| + 1 so you jave to deal wiht the signs
     cons1 = sigma/sqrt(phi);
     alpha  = cons0/cons1;//*sqrt((1 - fb*fb));
     beta = fb;//*alpha;
     //gamma = sqrt(alpha*alpha - beta*beta);
     delta = cons0*cons1;
     //printf("%e\n",phi);
     //printf("%e\n",cons0);
     //printf("%e\n",cons1);
     //printf("%e\n",exp(beta*d));
     //printf("%e\n",alpha);
     //printf("%e\n",delta);
     //printf("%e\n",LogEval(x,l,alpha,beta,delta, mu));
     
     if (d > -asigma ) return LogEval(d,l,alpha,beta,delta);
     k1 = LogEval(-asigma,l,alpha,beta,delta);
     k2 = diff_eval(-asigma,l,alpha,beta,delta);
     B = -asigma + n*k1/k2;
     A = k1*pow(B+asigma,n);
     out =  A*pow(B-d,-n);

     //return LogEval(x,l,alpha,beta,delta, mu);

   }
   else if (l < 0) {
     beta = fb;
     cons1 = -2*l;
     delta = sigma;
     if (d > -asigma ) return  exp(beta*d)*pow(1 + d*d/(delta*delta),l-0.5);
     cons1 = exp(-beta*asigma);
     phi = 1 + a*a;
     k1 = cons1*pow(phi,l-0.5);
     k2 = beta*k1- cons1*(l-0.5)*pow(phi,l-1.5)*2*a/delta;
     B = -asigma + n*k1/k2;
     A = k1*pow(B+asigma,n);
     out = A*pow(B-d,-n);

   }
  
   return out;

 } 



